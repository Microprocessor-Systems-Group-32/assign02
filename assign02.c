#include <stdio.h>
#include <stdlib.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
//#include "ws2812.pio.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

// Must declare the main assembly entry point before use.
void main_asm();

// Initialise GPIO pin
void asm_gpio_init(uint pin)
{
    gpio_init(pin);
}

// Set direction of a GPIO pin
void asm_gpio_set_dir(uint pin, bool out)
{
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin
bool asm_gpio_get(uint pin)
{
    return gpio_get(pin);
}

// Set the value of a GPIO pin
void asm_gpio_put(uint pin, bool value)
{
    gpio_put(pin, value);
}

// Set the IRQ of a GPIO pin
void asm_gpio_set_irq(uint pin)
{
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

struct letter {
    char letter; // char representation of letter
    char *morse_code; // morse code representation of letter, in binary string format
};

// Creates an instance of letter.
struct letter letter_create(char letter, char *morse_code) {
    struct letter output;
    output.letter = letter;
    output.morse_code = morse_code;
    return output;
}

struct letter letter_array[37];
void letter_array_create() {
    letter_array[0] = letter_create('A',".-");
    letter_array[1] = letter_create('B',"-...");
    letter_array[2] = letter_create('C',"-.-.");
    letter_array[3] = letter_create('D',"-..");
    letter_array[4] = letter_create('E',".");
    letter_array[5] = letter_create('F',"..-.");
    letter_array[6] = letter_create('G',"--.");
    letter_array[7] = letter_create('H',"....");
    letter_array[8] = letter_create('I',"..");
    letter_array[9] = letter_create('J',".---");
    letter_array[10] = letter_create('K',"-.-");
    letter_array[11] = letter_create('L',".-..");
    letter_array[12] = letter_create('M',"--");
    letter_array[13] = letter_create('N',"-.");
    letter_array[14] = letter_create('O',"---");
    letter_array[15] = letter_create('P',".--.");
    letter_array[16] = letter_create('Q',"--.-");
    letter_array[17] = letter_create('R',".-.");
    letter_array[18] = letter_create('S',"...");
    letter_array[19] = letter_create('T',"-");
    letter_array[20] = letter_create('U',"..-");
    letter_array[21] = letter_create('V',"...-");
    letter_array[22] = letter_create('W',".--");
    letter_array[23] = letter_create('X',"-..-");
    letter_array[24] = letter_create('Y',"-.--");
    letter_array[25] = letter_create('Z',"--..");
    letter_array[26] = letter_create('0',"-----");
    letter_array[27] = letter_create('1',".----");
    letter_array[28] = letter_create('2',"..---");
    letter_array[29] = letter_create('3',"...--");
    letter_array[30] = letter_create('4',"....-");
    letter_array[31] = letter_create('5',".....");
    letter_array[32] = letter_create('6',"-....");
    letter_array[33] = letter_create('7',"--...");
    letter_array[34] = letter_create('8',"---..");
    letter_array[35] = letter_create('9',"----.");
    letter_array[36] = letter_create('?',"..--..");
}

struct player
{
    int currentRound; 
    int highestRound;
    int lives; 
    int wins; 
    int totalCorrectAnswers;
};

void playerReset(struct player * player) {
    player->currentRound = 0;
    player->highestRound = 0;
    player->lives = 3;
    player->wins = 0;
    player->totalCorrectAnswers = 0;
}

void welcome(){
    printf("__        _______ _     ____ ___  __  __ _____ \n");
    printf("\\ \\      / / ____| |   / ___/ _ \\|  \\/  | ____| \n");
    printf(" \\ \\ /\\ / /|  _| | |  | |  | | | | |\\/| |  _|  \n");
    printf("  \\ V  V / | |___| |__| |__| |_| | |  | | |___  \n");
    printf("   \\_/\\_/  |_____|_____\\____\\___/|_|  |_|_____| \n");
    printf("  ____ ____   ___  _   _ ____    _________  \n");
    printf(" / ___|  _ \\ / _ \\| | | |  _ \\  |___ /___ \\ \n");
    printf("| |  _| |_) | | | | | | | |_) |   |_ \\ __) | \n");
    printf("| |_| |  _ <| |_| | |_| |  __/   ___) / __/ \n");
    printf(" \\____|_|\\_  \\___/ \\___/|_|     |____/_____| \n");

    printf("\n       WELCOME TO OUR MORSE CODE GAME!        \n");
    printf("       PRESS THE GPIO PIN 21 TO CONTINUE        \n");
}

void instructions(){
    printf("\n                 HOW TO PLAY\n");
    printf("You must enter the correct morse code sequence \n");
    printf("There are 4 levels in total - each level is 5 rounds!\n");
    printf("You have 3 lives before the game is over. \n");
    printf("\n");
    printf("1. For a dot (.), Hold down GPIO PIN 21 <0.25s \n");
    printf("2. For a dash (-), Hold down GPIO PIN 21 for >0.25s \n");
    printf("3. For a space, Leave the button unpressed for 1s \n");
    printf("4. To submit, Leave the button unpressed for 2s \n");
    printf("\n");
    printf("\n           CHOOSE YOUR DIFFICULTY: \n");
    printf("\n");
    printf("            LEVEL 1: PRESS 1 TIME\n");
    printf("            LEVEL 2: PRESS 2 TIMES\n");
    printf("            LEVEL 3: PRESS 3 TIMES\n");
    printf("            LEVEL 4: PRESS 4 TIMES\n");
}

void selectDifficulty(){
    int currentLevel;
    if(strcmp(currentInput, ".----")==0){
        currentLevel = level(1);
    }
    else if(strcmp(currentInput, "..---")==0){
        currentLevel = level(2);
    }
    else if(strcmp(currentInput, "...--")==0){
        currentLevel = level(3);
    }
    else if(strcmp(currentInput, "...--")==0){
        currentLevel = level(4);
    }
    else{
        printf("Invalid input.");
        return;
    }
}

void difficultyLevelInputs(){
    // Characters (Levels 1 and 2)
    if(letter == 1){
        currentLetter = rand_array[num_count]->letter;
        currentMorse = rand_array[num_count]->morse_name;
        // Morse Code Provided
        if(disp_morse == 1){
            printf("\n\t\tYour Challenge is: %c \n\t\tand %c in Morse is %s:\n", currentLetter, currentLetter, currentMorse);
        }
        else{
            printf("\n\t\tYour Challenge is: %c\n", currentLetter);
        }
    }
    // Words (Levels 3 and 4)
    else{
        for(int i = 0; i<3; i++){
            currentWord[i] = rand_array[num_count]->letter;
            strcat(currentMorse2, rand_array[num_count]->morse_name);
            if(i != 2){
                strcat(currentMorse2, space);
            }
            num_count = rand() % 36;
        }
        current_word[3] = '\0';
        currentMorse = currentMorse2;
        if(disp_morse == 1){
            printf("\n\t\tYour Challenge is: %s \n\t\tand %s in Morse, it's %s:\n", currentWord, currentWord, currentMorse);
        }
        else{
            printf("\n\t\tYour Challenge is: %s\n", currentWord);
        }
    }
}

void processInputData(){
    if(strcmp(currentMorse,currentInput)==0){
        printf("\n\t\tCorrect!\n");
        rightInput++;
        victory_count++;
        if(lives<3){
            lives++;
        }
        if(victory_count == 5){
            printf("\n\t\tYou Win!\n");
            if(currentLevel==4){
                prinrf("\n\t\tCongratulations! You have completed all levels!\n");
                winning_sequence();
                break;
            }
            currentLevel = level(currentLevel+1);
            printf("\n\n\t\t#################################################\n\n");
            printf("\t\t\t\tAdvancing to Level %d\n\n", currentLevel);
            printf("\n\n\t\t#################################################\n\n");
            calculateStats(1);
            victory_count = 0;
        }
    }
    else{
        printf("\n\t\tIncorrect!\n");
        wrongInput++;
        if(strcmp(hashTable[pos]->morse_name, "")==0){
            printf("\t\tMorse Code does not exist\n");
        }
        else if(letter){
            printf("\t\tMorse Code you entered is for %c\n", hashTable[pos]->letter);
        }
        lives--;
        victory_count = 0;
    }
    num_count = rand() % 36;
    set_correct_led();
    currentInput[0] = '\0';
    currentMorse2[0] = '\0';
    if(rightInput+wrongInput){
        calculateStats(0);
    }
}

void set_corrrect_led(){
    if(lives == 1) set_orange_on();
    else if(lives == 2) set_yellow_on();
    else set_green_on();
    return;
}

start_game(){
    
}

void gameFinished(){
    calculateStats(1);
    if(lives == 0) set_red_on();
    printf("\n\n\n\n\n\n\t\t*****************************\n");
    printf("\t\t*                           *\n");
    printf("\t\t* Enter .---- to play again *\n");
    printf("\t\t* Enter ..--- to exit       *\n");
    printf("\t\t*****************************\n");
    currentIndex = -1;
    main_asm();
    if(currentIndex == 0){
        printf("\t\tNo update detected\n\t\tProgram will now exit.");
    }
    if(strcmp(currentIndex, ".----")==0){
        start_game();
    }
}

/**
 * @brief A function called upon in start the game function that
 * calculates your overall accuracy throughout the game by
 * summing your total attempts over the total correct attempts.
*/

void calculateStats(int reset){
    printf("\n\n\t\t***************STATS***************\n\n");
    printf("\n\t\t*Attempts: \t\t\t\t%d*", rightInput+wrongInput);
    printf("\n\t\t*Correct: \t\t\t\t%d*", rightInput);
    printf("\n\t\t*Incorrect: \t\t\t\t%d*", wrongInput);
    printf("\n\t\t*Accuracy: \t\t\t\t%.2f%%*", (float)rightInput/(rightInput+wrongInput)*100);
    printf("\n\t\t*Win Streak: \t\t\t\t%d*", victory_count);
    printf("\n\t\t*Lives Left: \t\t\t\t%d*", lives);
    if(rightInput!=0 || wrongInput!=0){
        float stat = rightInput/(rightInput+wrongInput)*100;
        if(reset){
            rightInput = 0;
            wrongInput = 0;
            printf("\t\t*Correct %% for this level: \t%.2f%%*\n", stat);
        }
        else{
            printf("\t\t*Correct Percent :\t\t\t%.2f%%*\n", stat);
        }
    }
    printf("\n\t\t**********************************\n\n");
}


/**
 * @brief EXAMPLE - WS2812_RGB
 *        Simple example to initialise the NeoPixel RGB LED on
 *        the MAKER-PI-PICO and then flash it in alternating
 *        colours between red, green and blue forever using
 *        one of the RP2040 built-in PIO controllers.
 * 
 * @return int  Application return code (zero for success).
 */
int main()
{
    // Initialise all STDIO as we will be using the GPIOs
     stdio_init_all();

    // Initialise the PIO interface with the WS2812 code
    // PIO pio = pio0;
    // uint offset = pio_add_program(pio, &ws2812_program);
    // ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);


    // Initialise the array of letters
    letter_array_create();

    welcome();
    instructions();
    main_asm();
    printf("\n\n\n")
    selectDifficulty();

    difficultyLevelInputs();
    processInputData();


    
    return (0);
}