#include <stdio.h>
#include <stdlib.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"

// #include "ws2812.pio.h"

#define IS_RGBW true  // Will use RGBW format
#define NUM_PIXELS 1  // There is 1 WS2812 device in the chain
#define WS2812_PIN 28 // The GPIO pin that the WS2812 connected to

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 *
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb)
{
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 *
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b)
{
    return ((uint32_t)(r) << 8) |
           ((uint32_t)(g) << 16) |
           (uint32_t)(b);
}

// Must declare the main assembly entry point before use.
void main_asm();

// Initialise GPIO pin
void asm_gpio_init(uint pin)
{
    gpio_init(pin);
}

// Set direction of a GPIO pin
void asm_gpio_set_dir(uint pin, bool out)
{
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin
bool asm_gpio_get(uint pin)
{
    return gpio_get(pin);
}

// Set the value of a GPIO pin
void asm_gpio_put(uint pin, bool value)
{
    gpio_put(pin, value);
}

// Set the IRQ of a GPIO pin
void asm_gpio_set_irq(uint pin)
{
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

struct letter
{
    char letter;      // char representation of letter
    char *morse_code; // morse code representation of letter, in binary string format
};

// Creates an instance of letter.
struct letter letter_create(char letter, char *morse_code)
{
    struct letter output;
    output.letter = letter;
    output.morse_code = morse_code;
    return output;
}

struct letter letter_array[37];
void letter_array_create()
{
    letter_array[0] = letter_create('A', ".-");
    letter_array[1] = letter_create('B', "-...");
    letter_array[2] = letter_create('C', "-.-.");
    letter_array[3] = letter_create('D', "-..");
    letter_array[4] = letter_create('E', ".");
    letter_array[5] = letter_create('F', "..-.");
    letter_array[6] = letter_create('G', "--.");
    letter_array[7] = letter_create('H', "....");
    letter_array[8] = letter_create('I', "..");
    letter_array[9] = letter_create('J', ".---");
    letter_array[10] = letter_create('K', "-.-");
    letter_array[11] = letter_create('L', ".-..");
    letter_array[12] = letter_create('M', "--");
    letter_array[13] = letter_create('N', "-.");
    letter_array[14] = letter_create('O', "---");
    letter_array[15] = letter_create('P', ".--.");
    letter_array[16] = letter_create('Q', "--.-");
    letter_array[17] = letter_create('R', ".-.");
    letter_array[18] = letter_create('S', "...");
    letter_array[19] = letter_create('T', "-");
    letter_array[20] = letter_create('U', "..-");
    letter_array[21] = letter_create('V', "...-");
    letter_array[22] = letter_create('W', ".--");
    letter_array[23] = letter_create('X', "-..-");
    letter_array[24] = letter_create('Y', "-.--");
    letter_array[25] = letter_create('Z', "--..");
    letter_array[26] = letter_create('0', "-----");
    letter_array[27] = letter_create('1', ".----");
    letter_array[28] = letter_create('2', "..---");
    letter_array[29] = letter_create('3', "...--");
    letter_array[30] = letter_create('4', "....-");
    letter_array[31] = letter_create('5', ".....");
    letter_array[32] = letter_create('6', "-....");
    letter_array[33] = letter_create('7', "--...");
    letter_array[34] = letter_create('8', "---..");
    letter_array[35] = letter_create('9', "----.");
    letter_array[36] = letter_create('?', "..--..");
}

// Global variables
int currentLevel = 0;
int highestLevel = 0;
int lives = 3;
int wins = 0;
int totalCorrectAnswers = 0;
int rightInput = 0;
int wrongInput = 0;

void welcome(){
    printf("__        _______ _     ____ ___  __  __ _____ \n");
    printf("\\ \\      / / ____| |   / ___/ _ \\|  \\/  | ____| \n");
    printf(" \\ \\ /\\ / /|  _| | |  | |  | | | | |\\/| |  _|  \n");
    printf("  \\ V  V / | |___| |__| |__| |_| | |  | | |___  \n");
    printf("   \\_/\\_/  |_____|_____\\____\\___/|_|  |_|_____| \n");
    printf("  ____ ____   ___  _   _ ____    _________  \n");
    printf(" / ___|  _ \\ / _ \\| | | |  _ \\  |___ /___ \\ \n");
    printf("| |  _| |_) | | | | | | | |_) |   |_ \\ __) | \n");
    printf("| |_| |  _ <| |_| | |_| |  __/   ___) / __/ \n");
    printf(" \\____|_|\\_  \\___/ \\___/|_|     |____/_____| \n");

    printf("\n       WELCOME TO OUR MORSE CODE GAME!        \n");
    printf("       PRESS THE GPIO PIN 21 TO CONTINUE        \n");
}

void instructions(){
    printf("\n                 HOW TO PLAY\n");
    printf("You must enter the correct morse code sequence \n");
    printf("There are 4 levels in total - each level is 5 rounds!\n");
    printf("You have 3 lives before the game is over. \n");
    printf("\n");
    printf("1. For a dot (.), Hold down GPIO PIN 21 <0.25s \n");
    printf("2. For a dash (-), Hold down GPIO PIN 21 for >0.25s \n");
    printf("3. For a space, Leave the button unpressed for 1s \n");
    printf("4. To submit, Leave the button unpressed for 2s \n");
    printf("\n");
    printf("\n           CHOOSE YOUR DIFFICULTY: \n");
    printf("\n");
    printf("            LEVEL 1: PRESS 1 TIME\n");
    printf("            LEVEL 2: PRESS 2 TIMES\n");
    printf("            LEVEL 3: PRESS 3 TIMES\n");
    printf("            LEVEL 4: PRESS 4 TIMES\n");
}

void selectDifficulty(){
    struct letter null = letter_create(' ', " ");
    while(true){
        input = "";
        playerInput();
        if(strcmp(currentInput, ".----")==0){
            currentLevel = 1;
            return;
        }
        else if(strcmp(currentInput, "..---")==0){
            currentLevel = 2;
            return;
        }
        else if(strcmp(currentInput, "...--")==0){
            currentLevel = 3;
            return;
        }
        else if(strcmp(currentInput, "...--")==0){
            currentLevel = 4;
            return;
        }
        else{
            printf("Invalid input.");
            return;
        }
    }
}

void playerInput(){
    // ToDo
}

void difficultyLevelInputs(){
    // Characters (Levels 1 and 2)
    if(letter == 1){
        currentLetter = rand_array[num_count]->letter;
        currentMorse = rand_array[num_count]->morse_name;
        // Morse Code Provided
        if(disp_morse == 1){
            printf("\n\t\tYour Challenge is: %c \n\t\tand %c in Morse is %s:\n", currentLetter, currentLetter, currentMorse);
        }
        else{
            printf("\n\t\tYour Challenge is: %c\n", currentLetter);
        }
    }
    // Words (Levels 3 and 4)
    else{
        for(int i = 0; i<3; i++){
            currentWord[i] = rand_array[num_count]->letter;
            strcat(currentMorse2, rand_array[num_count]->morse_name);
            if(i != 2){
                strcat(currentMorse2, space);
            }
            num_count = rand() % 36;
        }
        current_word[3] = '\0';
        currentMorse = currentMorse2;
        if(disp_morse == 1){
            printf("\n\t\tYour Challenge is: %s \n\t\tand %s in Morse, it's %s:\n", currentWord, currentWord, currentMorse);
        }
        else{
            printf("\n\t\tYour Challenge is: %s\n", currentWord);
        }
    }
}

void processInputData(){
    if(strcmp(currentMorse,currentInput)==0){
        printf("\n\t\tCorrect!\n");
        rightInput++;
        wins++;
        if(lives<3){
            lives++;
        }
        if(wins == 5){
            printf("\n\t\tYou Win!\n");
            if(currentLevel==4){
                prinrf("\n\t\tCongratulations! You have completed all levels!\n");
                winning_sequence();
                break;
            }
            currentLevel = currentLevel + 1;
            printf("\n\n\t\t#################################################\n\n");
            printf("\t\t\t\tAdvancing to Level %d\n\n", currentLevel);
            printf("\n\n\t\t#################################################\n\n");
            calculateStats(1);
            wins = 0;
        }
    }
    else{
        printf("\n\t\tIncorrect!\n");
        wrongInput++;
        if(strcmp(hashTable[pos]->morse_name, "")==0){
            printf("\t\tMorse Code does not exist\n");
        }
        else if(letter){
            printf("\t\tMorse Code you entered is for %c\n", hashTable[pos]->letter);
        }
        lives--;
        victory_count = 0;
    }
    num_count = rand() % 36;
    set_correct_led();
    currentInput[0] = '\0';
    currentMorse2[0] = '\0';
    if(rightInput+wrongInput){
        calculateStats(0);
    }
}

void set_corrrect_led(){
    if(currentRound != 0){
        switch(numberOfLives){
            case 3:
                // Set Green
                put_pixel(urgb_u32(0x0,0x3F,0x0));
                break;
            case 2:
                // Set Yellow
                put_pixel(urgb_u32(0x3F,0x3F,0x0));
                break;
            case 1:
                // Set Red
                put_pixel(urgb_u32(0x3F,0x0,0x0));
                break;
            default:
                break;
        }
    }
    else{
        // Set Blue
        put_pixel(urgb_u32(0x0,0x0,0x3F));
    }
}


start_game(){
    int correctAnswerStreak = 0;
    printf("\nLevel %d\n", currentRound);
    bool isCorrect;
    //update the colour of the LED based on the player's lives
    set_corrrect_led();
    while(correctAnswerStreak != 5 && numberOfLives != 0){
        //Reset input
        input = "";
        flag = 0;
        //If correct, correctAnswers and numberOfLives +1 (up to 3 lives)
        //If incorrect, numberOfLives--

        isCorrect = false;
        //produce a random letter from our letter_array (0 to 37)
        struct letter l;
        srand(seed);
        int index = rand() % 36;

        switch(currentRound){
            case 1:
                l = letter_array[index];
                //print a line of text giving the player their letter AND the morse code variant (see the letter struct for reference)
                printf("\nType the morse code for the letter\n'%c' -> \"%s\"\n", l.letter, l.morse_code);
                playerInput(l);
                if(strcmp(input, l.morse_code) == 0)
                    isCorrect = true; 
                break;
            case 2:
                l = letter_array[index];
                //print a line of text giving the player their letter AND the morse code variant (see the letter struct for reference)
                printf("\nType the morse code for the letter\n'%c'\n", l.letter);
                playerInput(l);
                if(strcmp(input, l.morse_code) == 0)
                    isCorrect = true; 
                break;
            case 3:
                //print a line of text giving the player their word AND the morse code variant (see the letter struct for reference)
                break;
            case 4:
                //print a line of text giving the player JUST their word
                break;
            default:
                printf("Something went wrong. Sorry!\n");
                break;
        }

        
        if(isCorrect) {
            printf("\nCorrect! \"%s\" is the morse code for '%c'\n", input, l.letter);
            if(numberOfLives != 3)
                numberOfLives++;
            correctAnswerStreak++;
            totalCorrectAnswers++;
        }

        else {
            printf("\nOh no, that's not right. The morse code for '%c' is \"%s\". Try Again!\n", l.letter, l.morse_code);
            correctAnswerStreak = 0;
            numberOfLives--;
        }

        printf("\nCurrent Streak: %d\n", correctAnswerStreak);
        //update the colour of the LED based on the player's lives
        updateLED();
        watchdog_update();
    }
    if(numberOfLives == 0 || currentRound == 2)
        gameFinished();
}

void gameFinished(){
    calculateStats(1);
    if(lives == 0) set_red_on();
    printf("\n\n\n\n\n\n\t\t*****************************\n");
    printf("\t\t*                           *\n");
    printf("\t\t* Enter .---- to play again *\n");
    printf("\t\t* Enter ..--- to exit       *\n");
    printf("\t\t*****************************\n");
    currentIndex = -1;
    main_asm();
    if(currentIndex == 0){
        printf("\t\tNo update detected\n\t\tProgram will now exit.");
    }
    if(strcmp(currentIndex, ".----")==0){
        start_game();
    }
}

/**
 * @brief A function called upon in start the game function that
 * calculates your overall accuracy throughout the game by
 * summing your total attempts over the total correct attempts.
*/

void calculateStats(int reset){
    printf("\n\n\t\t***************STATS***************\n\n");
    printf("\n\t\t*Attempts: \t\t\t\t%d*", rightInput+wrongInput);
    printf("\n\t\t*Correct: \t\t\t\t%d*", rightInput);
    printf("\n\t\t*Incorrect: \t\t\t\t%d*", wrongInput);
    printf("\n\t\t*Accuracy: \t\t\t\t%.2f%%*", (float)rightInput/(rightInput+wrongInput)*100);
    printf("\n\t\t*Win Streak: \t\t\t\t%d*", wins);
    printf("\n\t\t*Lives Left: \t\t\t\t%d*", lives);
    if(rightInput!=0 || wrongInput!=0){
        float stat = rightInput/(rightInput+wrongInput)*100;
        if(reset){
            rightInput = 0;
            wrongInput = 0;
            printf("\t\t*Correct %% for this level: \t%.2f%%*\n", stat);
        }
        else{
            printf("\t\t*Correct Percent :\t\t\t%.2f%%*\n", stat);
        }
    }
    printf("\n\t\t**********************************\n\n");
}
/**
 * @brief EXAMPLE - WS2812_RGB
 *        Simple example to initialise the NeoPixel RGB LED on
 *        the MAKER-PI-PICO and then flash it in alternating
 *        colours between red, green and blue forever using
 *        one of the RP2040 built-in PIO controllers.
 *
 * @return int  Application return code (zero for success).
 */
int main()
{
    // Initialise all STDIO as we will be using the GPIOs
     stdio_init_all();

    // Initialise the PIO interface with the WS2812 code
    // PIO pio = pio0;
    // uint offset = pio_add_program(pio, &ws2812_program);
    // ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    // Initialise the array of letters
    letter_array_create();



    welcome();
    instructions();
    main_asm();
    printf("\n\n\n")
    selectDifficulty();

    difficultyLevelInputs();
    processInputData();

    
    return (0);
}